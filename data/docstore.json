[["0",{"pageContent":"./mercury.py https://beta.nextjs.org/docs/getting-started\n./mercury.py https://beta.nextjs.org/docs/routing/fundamentals\n./mercury.py -f md https://beta.nextjs.org/docs/rendering/fundamentals\n./mercury.py -f md https://beta.nextjs.org/docs/data-fetching/fundamentals\n./mercury.py -f md https://beta.nextjs.org/docs/api-reference/next.config.js#transpilepackages\n\n\ndate: None\nauthor(s): None\n\n# [Getting Started](https://beta.nextjs.org/docs/getting-started)\n\n> The Next.js documentation is divided into two sites:\n\nOver the past few months, the Next.js team has been working to integrate Next.js with [React Server Components](/docs/rendering/server-and-client-components) and [React 18 features](https://reactjs.org/blog/2022/03/29/react-v18.html). These new features are now available to try in the new `app` directory.\n\n> ðŸ—ï¸ The App Router is currently in beta and we do not recommend using it in production.","metadata":{"source":"NextAPI.md"}}],["1",{"pageContent":"> ðŸ—ï¸ The App Router is currently in beta and we do not recommend using it in production.\n\nHere's a summary of the new features in the [App Router](/docs/routing/fundamentals#the-app-directory):","metadata":{"source":"NextAPI.md"}}],["2",{"pageContent":"Features| What's New?\n---|---\n[Routing](/docs/routing/fundamentals)| New file-system based router built on top of Server Components that supports layouts, nested routing, loading states, error handling, and more.\n[Rendering](/docs/rendering/fundamentals)| Client-side and Server-side Rendering with Client and Server Components. Further optimized with Static and Dynamic Rendering on the server with Next.js. Streaming on Edge and Node.js runtimes.\n[Data Fetching](/docs/data-fetching/fundamentals)| Simplified data fetching with `async`/`await` support in React Components and the `fetch()` API that aligns with React and the Web Platform.\nCaching| New [Next.js HTTP Cache](/docs/data-fetching/fundamentals#caching-data) and [client-side cache](/docs/routing/linking-and-navigating#client-side-caching-of-rendered-server-components) optimized for Server Components and client-side navigation.","metadata":{"source":"NextAPI.md"}}],["3",{"pageContent":"Optimizations| Improved [Image Component](/docs/optimizing/images) with native browser lazy loading. New [Font Module](/docs/optimizing/fonts) with automatic font optimization.\n[Transpilation](/docs/api-reference/next.config.js#transpilepackages)| Automatic transpilation and bundling of dependencies from local packages (like monorepos) or from external dependencies (`node_modules`).\nAPI| Updates to the API design throughout Next.js. Please refer to the API Reference Section for new APIs.\nTooling| Introducing [Turbopack](https://turbo.build/pack), up to 700x faster Rust-based Webpack replacement.","metadata":{"source":"NextAPI.md"}}],["4",{"pageContent":"For a more extensive list, check out the [App Router Roadmap](/docs/app-directory-roadmap).\n\nSimilar to how [React changed the way we think about building UIs](https://beta.reactjs.org/learn/thinking-in-react), React Server Components introduce a **new mental model** for building hybrid applications that leverage the [server and the client](/docs/rendering/server-and-client-components).\n\nInstead of React rendering your **whole application** client-side, React now gives you the flexibility to choose where to render your **components** based on their purpose.\n\nFor example, consider a [page](https://nextjs.org/docs/basic-features/pages) in your Next.js application:\n\n![Server and Client Components](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1667581343/nextjs-docs/darkmode/thinking-in-server-components.png)","metadata":{"source":"NextAPI.md"}}],["5",{"pageContent":"![Server and Client Components](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1667581343/nextjs-docs/darkmode/thinking-in-server-components.png)\n\nIf we were to split the page into smaller components, you'll notice that the majority of components are non-interactive and can be rendered on the server as Server Components. For smaller pieces of interactive UI, we can _sprinkle in_ Client Components. This aligns with Next.js server-first approach.\n\nTo make this transition easier, Server Components are the default in the `app` directory, so you do not have to take additional steps to adopt them. Then, you can optionally opt-in to Client Components when needed.\n\nTo learn more, check out our guide on [Server and Client Components](/docs/rendering/server-and-client-components).","metadata":{"source":"NextAPI.md"}}],["6",{"pageContent":"To learn more, check out our guide on [Server and Client Components](/docs/rendering/server-and-client-components).\n\nWe'd love your feedback as we're working on the new docs. You'll notice a toolbar at the bottom of the screen. You can [comment](https://vercel.com/docs/concepts/deployments/comments) with a Vercel account and leave feedback directly on the pages.\n\nFeedback that would be helpful:\n\n  * Typos and other small mistakes.\n  * Confusing or unclear explanations.\n  * Missing information.\n  * Questions that you had while reading the docs.\n\n\n\nFor feedback on Next.js features and API design, please use [GitHub Discussions](https://github.com/vercel/next.js/discussions/41745).\n\nFinally, let's get started! What would you like to do?\n\n[Learn how to use the new features in the App Router (beta).](/docs/installation)\n\n[Learn how Next.js turns your code into user interfaces.](/docs/upgrade-guide)\n\n[Learn about stable, in-progress, and upcoming features.](/docs/app-directory-roadmap)","metadata":{"source":"NextAPI.md"}}],["7",{"pageContent":"[Learn how Next.js turns your code into user interfaces.](/docs/upgrade-guide)\n\n[Learn about stable, in-progress, and upcoming features.](/docs/app-directory-roadmap)\n\n\ndate: None\nauthor(s): None\n\n# [Routing: Fundamentals](https://beta.nextjs.org/docs/routing/fundamentals)\n\nNext.js 13 introduced the new **App Router** built on top of [React Server Components](/docs/rendering/server-and-client-components) with support for layouts, nested routing, loading states, error handling, and more.\n\nThis page will introduce you to the **fundamental concepts** of the new routing model.\n\nYou will see these terms being used throughout the documentation. Here's a quick reference:\n\n![A tree of folders with a subtree, root, and leaves](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1666568302/nextjs-docs/darkmode/terminology-component-tree.png)","metadata":{"source":"NextAPI.md"}}],["8",{"pageContent":"![A tree of folders with a subtree, root, and leaves](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1666568302/nextjs-docs/darkmode/terminology-component-tree.png)\n\n  * **Tree:** A convention for visualizing a hierarchical structure. For example, a component tree with parent and children components, a folder structure, etc.\n  * **Subtree:** Part of a tree, starting at a new root (first) and ending at the leaves (last).\n  * **Root** : The first node in a tree or subtree, such as a root layout.\n  * **Leaf:** Nodes in a subtree that have no children, such as the last segment in a URL path.\n\n![Anatomy of a URL](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1666568301/nextjs-docs/darkmode/terminology-url-anatomy.png)\n\n  * **URL Segment:** Part of the URL path delimited by slashes.\n  * **URL Path:** Part of the URL that comes after the domain (composed of segments).","metadata":{"source":"NextAPI.md"}}],["9",{"pageContent":"* **URL Segment:** Part of the URL path delimited by slashes.\n  * **URL Path:** Part of the URL that comes after the domain (composed of segments).\n\n\n\nThe new App Router works in a new directory named `app`. The `app` directory works alongside the `pages` directory to allow for incremental adoption. This allows you to opt some routes of your application into the new behavior while keeping other routes in the `pages` directory for previous behavior.\n\n> **Good to know:** Routes across directories should not resolve to the same URL path and will cause a build-time error to prevent a conflict.\n\n![The new app directory with folders as routes](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1666387689/nextjs-docs/darkmode/app-folder-page-folder.png)","metadata":{"source":"NextAPI.md"}}],["10",{"pageContent":"![The new app directory with folders as routes](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1666387689/nextjs-docs/darkmode/app-folder-page-folder.png)\n\nBy default, components inside `app` are [React Server Components](/docs/rendering/server-and-client-components). This is a performance optimization and allows you to easily adopt them. However, you can also use [Client Components](/docs/rendering/server-and-client-components#client-components).\n\n> **Recommendation:** Check out the [Server and Client Components](/docs/rendering/server-and-client-components) page if you're new to Server Components.\n\nIn the `app` directory:\n\n  * **Folders** are used to define routes. A route is a single path of nested folders, following the hierarchy from the **root folder** down to a final **leaf folder** that includes a `page.js` file.\n  * **Files** are used to create UI that is shown for the route segment. See [special files](/docs/routing/fundamentals#file-conventions).","metadata":{"source":"NextAPI.md"}}],["11",{"pageContent":"Each folder in a route represents a **route segment**. Each route segment is mapped to a corresponding **segment** in a **URL path**.\n\n![Route segments mapping to URL segments](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1666568300/nextjs-docs/darkmode/route-segments-to-path-segments.png)\n\nTo create a nested route, you can nest folders inside each other. For example, you can add a new `/dashboard/settings` route by nesting two new folders in the `app` directory.\n\nThe `/dashboard/settings` route is composed of three segments:\n\n  * `/` (Root segment)\n  * `dashboard` (Segment)\n  * `settings` (Leaf segment)\n\n\n\nNext.js provides a set of special files to create UI with specific behavior in nested routes:","metadata":{"source":"NextAPI.md"}}],["12",{"pageContent":"* [**page.js**](/docs/routing/pages-and-layouts#pages): Create the unique UI of a route and make the path publicly accessible.\n    * [**route.js**](/docs/routing/route-handlers): Create server-side API endpoints for a route (available in next@canary).\n  * [**layout.js**](/docs/routing/pages-and-layouts#layouts): Create shared UI for a segment and its children. A layout wraps a page or child segment.\n    * [**template.js**](/docs/routing/pages-and-layouts#templates): Similar to `layout.js`, except a new component instance is mounted on navigation. Use layouts unless you need this behavior.\n  * [**loading.js**](/docs/routing/loading-ui): Create loading UI for a segment and its children. `loading.js` wraps a page or child segment in a [React Suspense Boundary](https://beta.reactjs.org/apis/react/Suspense#suspense), showing the loading UI while they load.","metadata":{"source":"NextAPI.md"}}],["13",{"pageContent":"* [**error.js**](/docs/routing/error-handling): Create error UI for a segment and its children. `error.js` wraps a page or child segment in a [React Error Boundary](https://reactjs.org/docs/error-boundaries.html), showing the error UI if an error is caught.\n    * [**global-error.js**](/docs/routing/error-handling): Similar to `error.js`, but specifically for catching errors in the root `layout.js`.\n  * [**not-found.js**](/docs/api-reference/file-conventions/not-found): Create UI to show when the [`notFound`](/docs/api-reference/notfound) function is thrown within a route segment.","metadata":{"source":"NextAPI.md"}}],["14",{"pageContent":"> **Good to know:** `.js`, `.jsx`, or `.tsx` file extensions can be used for special files.\n\nThe React components defined in special files of a route segment are rendered in a specific hierarchy:\n\n  * `layout.js`\n  * `template.js`\n  * `error.js` (React error boundary)\n  * `loading.js` (React suspense boundary)\n  * `not-found.js` (React error boundary)\n  * `page.js` or nested `layout.js`\n\n![Rendered component hierarchy](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1675248777/nextjs-docs/darkmode/file-conventions-component-hierarchy.png)\n\nIn a nested route, the components of a segment will be nested **inside** the components of its parent segment.\n\n![Nested rendered component hierarchy](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1675248778/nextjs-docs/darkmode/nested-file-conventions-component-hierarchy.png)\n\nIn addition to special files, you have the option to colocate your own files inside folders. For example, stylesheets, tests, components, and more.","metadata":{"source":"NextAPI.md"}}],["15",{"pageContent":"In addition to special files, you have the option to colocate your own files inside folders. For example, stylesheets, tests, components, and more.\n\n![An example folder of colocated files](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1666568300/nextjs-docs/darkmode/collocating-assets-in-the-app-directory.png)\n\nUnlike the `pages` directory which uses client-side routing, the new router in the `app` directory uses **server-centric routing** to align with [Server Components](/docs/rendering/server-and-client-components) and [data fetching on the server](/docs/data-fetching/fundamentals#fetching-data-with-server-components). With server-centric routing, the client does not have to download a route map and the same request for Server Components can be used to look up routes. This optimization is useful for all applications, but has a larger impact on applications with many routes.","metadata":{"source":"NextAPI.md"}}],["16",{"pageContent":"Although routing is server-centric, the router uses **client-side navigation** with the [Link Component](/docs/routing/linking-and-navigating#linking) \\- resembling the behavior of a Single-Page Application. This means when a user navigates to a new route, the browser will not reload the page. Instead, the URL will be updated and Next.js will [only render the segments that change](/docs/routing/fundamentals#partial-rendering).\n\nAdditionally, as users navigate around the app, the router will store the result of the React Server Component payload in an **in-memory client-side cache**. The cache is split by route segments which allows invalidation at any level and ensures consistency across concurrent renders. This means that for certain cases, the cache of a previously fetched segment can be re-used, further improving performance.\n\nCheckout the [Linking and Navigating](/docs/routing/linking-and-navigating) page to learn how to use the Link component.","metadata":{"source":"NextAPI.md"}}],["17",{"pageContent":"Checkout the [Linking and Navigating](/docs/routing/linking-and-navigating) page to learn how to use the Link component.\n\nWhen navigating between sibling routes (e.g. `/dashboard/settings` and `/dashboard/analytics` below), Next.js will only fetch and render the layouts and pages in routes that change. It will **not** re-fetch or re-render anything above the segments in the subtree. This means that in routes that share a layout, the layout will be preserved when a user navigates between sibling pages.\n\n![Partial Rendering](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1671641891/nextjs-docs/darkmode/partial-rendering.png)\n\nWithout partial rendering, each navigation would cause the full page to re-render on the server. Rendering only the segment thatâ€™s updating reduces the amount of data transferred and execution time, leading to improved performance.","metadata":{"source":"NextAPI.md"}}],["18",{"pageContent":"In the future, the Next.js Router will provide a set of conventions to help you implement more advanced routing patterns. These include:\n\n  * **Parallel Routes** : Allow you to simultaneously show two or more pages in the same view that can be navigated independently. You can use them for split views that have their own sub-navigation. E.g. Dashboards.\n  * **Intercepting Routes** : Allow you to intercept a route and show it in the context of another route. You can use these when keeping the context for the current page is important. E.g. Seeing all tasks while editing one task or expanding a photo in a feed.\n  * **Conditional Routes** : Allow you to conditionally render a route based on a condition. E.g. Showing a page only if the user is logged in.\n\n\n\nThese patterns and conventions will allow you to build richer, more complex UIs in your Next.js applications.\n\n[Learn how to create routes in your Next.js application.](/docs/routing/defining-routes)","metadata":{"source":"NextAPI.md"}}],["19",{"pageContent":"These patterns and conventions will allow you to build richer, more complex UIs in your Next.js applications.\n\n[Learn how to create routes in your Next.js application.](/docs/routing/defining-routes)\n\n[Learn how to create pages and shared layouts.](/docs/routing/pages-and-layouts)\n\ndate: None\nauthor(s): None\n\n# [Rendering: Fundamentals](https://beta.nextjs.org/docs/rendering/fundamentals)\n\n**Rendering** converts the code you write into user interfaces.\n\nReact 18 and Next.js 13 introduced new ways to render your application. This page will help you understand the differences between rendering environments, strategies, runtimes, and how to opt into them.\n\nThere are two environments where your application code can be rendered: the **client** and the **server**.\n\n![Head File](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1666704761/nextjs-docs/darkmode/client-and-server.png)","metadata":{"source":"NextAPI.md"}}],["20",{"pageContent":"![Head File](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1666704761/nextjs-docs/darkmode/client-and-server.png)\n\n  * The **client** refers to the browser on a userâ€™s device that sends a request to a server for your application code. It then turns the response from the server into an interface the user can interact with.\n  * The **server** refers to the computer in a data center that stores your application code, receives requests from a client, does some computation, and sends back an appropriate response.\n\n\n\n> **Note:** Server is a general name that can refer to computers in [Origin Regions](https://vercel.com/docs/concepts/edge-network/overview#regions) where your application is deployed to, the [Edge Network](https://vercel.com/docs/concepts/edge-network/overview) where your application code is distributed, or [Content Delivery Networks (CDNs)](https://developer.mozilla.org/en-US/docs/Glossary/CDN) where the result of the rendering work can be cached.","metadata":{"source":"NextAPI.md"}}],["21",{"pageContent":"Before React 18, the primary way to render your application **using React** was entirely on the client.\n\nNext.js provided an easier way to break down your application into **pages** and prerender on the server by generating HTML and sending it to the client to be [hydrated](https://beta.reactjs.org/apis/react-dom/client/hydrateRoot#hydrating-server-rendered-html) by React. However, this led to additional JavaScript needed on the client to make the initial HTML interactive.\n\nNow, with [Server and Client Components](/docs/rendering/server-and-client-components), React can render on the client **and** the server meaning you can choose the rendering environment at the component level.\n\nBy default, the [`app` directory](/docs/routing/fundamentals#the-app-directory) uses **Server Components** , allowing you to easily render components on the server and reducing the amount of JavaScript sent to the client.","metadata":{"source":"NextAPI.md"}}],["22",{"pageContent":"You can interleave Server and Client Components in a component tree by [importing a Client Component into a Server component](/docs/rendering/server-and-client-components#convention), or by [passing a Server Component as a child or a prop to a Client Component](/docs/rendering/server-and-client-components#importing-server-components-into-client-components). Behind the scenes, React will merge the work of both environments.\n\n![A component tree showing interleaved Server and Client components](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1678098147/nextjs-docs/darkmode/component-tree.png)\n\nSee the [Server and Client Components page](/docs/rendering/server-and-client-components) to learn how to compose them.\n\nIn addition to client-side and server-side rendering with React components, Next.js gives you the option to optimize rendering on the server with **Static** and **Dynamic Rendering**.","metadata":{"source":"NextAPI.md"}}],["23",{"pageContent":"In addition to client-side and server-side rendering with React components, Next.js gives you the option to optimize rendering on the server with **Static** and **Dynamic Rendering**.\n\nWith **Static Rendering** , both Server _and_ Client Components can be prerendered on the server at **build time**. The result of the work is [cached](/docs/data-fetching/caching) and reused on subsequent requests. The cached result can also be [revalidated](/docs/data-fetching/fundamentals#revalidating-data).\n\n> **Note:** This is equivalent to [Static Site Generation (SSG)](https://nextjs.org/docs/basic-features/data-fetching/get-static-props) and [Incremental Static Regeneration (ISR)](https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration).\n\nServer and Client components are rendered differently during Static Rendering:","metadata":{"source":"NextAPI.md"}}],["24",{"pageContent":"Server and Client components are rendered differently during Static Rendering:\n\n  * Client Components have their HTML and JSON prerendered and cached on the server. The cached result is then sent to the client for hydration.\n  * Server Components are rendered on the server by React, and their payload is used to generate HTML. The same rendered payload is also used to hydrate the components on the client, resulting in no JavaScript needed on the client.\n\n\n\nWith **Dynamic Rendering** , both Server _and_ Client Components are rendered on the server at **request time**. The result of the work is not cached.\n\n> **Note:** This is equivalent to [Server-Side Rendering (`getServerSideProps()`)](https://nextjs.org/docs/api-reference/data-fetching/get-server-side-props).","metadata":{"source":"NextAPI.md"}}],["25",{"pageContent":"> **Note:** This is equivalent to [Server-Side Rendering (`getServerSideProps()`)](https://nextjs.org/docs/api-reference/data-fetching/get-server-side-props).\n\nTo learn more about static and dynamic behavior, see the [Static and Dynamic Rendering](/docs/rendering/static-and-dynamic-rendering) page. To learn more about caching, see the [Caching and Revalidating](/docs/data-fetching/fundamentals#caching-data) sections.\n\nOn the server, there are two runtimes where your pages can be rendered:\n\n  * The **Node.js Runtime** (default) has access to all Node.js APIs and compatible packages from the ecosystem.\n  * The **Edge Runtime** is based on [Web APIs](https://nextjs.org/docs/api-reference/edge-runtime).\n\n\n\nBoth runtimes support [streaming](/docs/data-fetching/streaming-and-suspense) from the server, depending on your deployment infrastructure.\n\nTo learn how to switch between runtimes, see the [Edge and Node.js Runtimes](/docs/rendering/edge-and-nodejs-runtimes) page.","metadata":{"source":"NextAPI.md"}}],["26",{"pageContent":"To learn how to switch between runtimes, see the [Edge and Node.js Runtimes](/docs/rendering/edge-and-nodejs-runtimes) page.\n\n[Learn when to use Client and Server Components.](/docs/rendering/server-and-client-components)\n\n[Learn how and when to implement Static or Dynamic Rendering.](/docs/rendering/static-and-dynamic-rendering)\n\n[Learn how to use the Edge Runtime to render and stream Server Components.](/docs/rendering/edge-and-nodejs-runtimes)\n\n\n# [Data Fetching: Fundamentals](https://beta.nextjs.org/docs/data-fetching/fundamentals)\n\nThe Next.js App Router introduces a new, simplified data fetching system built on React and the Web platform. This page will go through the **fundamental concepts** and **patterns** to help you manage your data's lifecycle.","metadata":{"source":"NextAPI.md"}}],["27",{"pageContent":"> **Good to know** : Previous Next.js data fetching methods such as [`getServerSideProps`](https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props), [`getStaticProps`](https://nextjs.org/docs/basic-features/data-fetching/get-static-props), and [`getInitialProps`](https://nextjs.org/docs/api-reference/data-fetching/get-initial-props) are **not** supported in the new `app` directory.\n\nHere's a quick overview of the recommendations on this page:\n\nThe new data fetching system is built on top of the native [`fetch()` Web API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) and makes use of `async`/`await` in Server Components.\n\n[Learn how to use `fetch` in Next.js](/docs/data-fetching/fetching).\n\nWhenever possible, we recommend fetching data inside [Server Components](/docs/rendering/server-and-client-components). Server Components **always fetch data on the server**. This allows you to:","metadata":{"source":"NextAPI.md"}}],["28",{"pageContent":"Whenever possible, we recommend fetching data inside [Server Components](/docs/rendering/server-and-client-components). Server Components **always fetch data on the server**. This allows you to:\n\n  * Have direct access to backend data resources (e.g. databases).\n  * Keep your application more secure by preventing sensitive information, such as access tokens and API keys, from being exposed to the client.\n  * Fetch data and render in the same environment. This reduces both the back-and-forth communication between client and server, as well as the work on the main thread on the client.\n  * Perform multiple data fetches with single round-trip instead of multiple individual requests on the client.\n  * Reduce client-server [waterfalls](/docs/data-fetching/fundamentals#parallel-and-sequential-data-fetching).\n  * Depending on your region, data fetching can also happen closer to your data source, reducing latency and improving performance.","metadata":{"source":"NextAPI.md"}}],["29",{"pageContent":"[Learn more about Client and Server Components](/docs/rendering/server-and-client-components).\n\n> **Good to know:** It's still possible to fetch data client-side. We recommend using a third-party library such as [SWR](https://swr.vercel.app/) or [React Query](https://tanstack.com/query/v4/) with Client components. In the future, it'll also be possible to fetch data in Client Components using React's [`use()` hook](/docs/data-fetching/fetching#use-in-client-components).\n\nIn this new model, you can fetch data inside [layouts](/docs/routing/pages-and-layouts#layouts), [pages](/docs/routing/pages-and-layouts#pages), and components. Data fetching is also compatible with [Streaming and Suspense](/docs/data-fetching/fundamentals#streaming-and-suspense).","metadata":{"source":"NextAPI.md"}}],["30",{"pageContent":"> **Good to know:** For layouts, it's not possible to pass data between a parent layout and its children. We recommend **fetching data directly inside the layout that needs it** , even if you're requesting the same data multiple times in a route. Behind the scenes, React and Next.js will [cache and dedupe](/docs/data-fetching/fundamentals#automatic-fetch-request-deduping) requests to avoid the same data being fetched more than once.\n\nWhen fetching data inside components, you need to be aware of two data fetching patterns: Parallel and Sequential.\n\n![Server and Client Components](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1669651658/nextjs-docs/darkmode/sequential-parallel-data-fetching.png)","metadata":{"source":"NextAPI.md"}}],["31",{"pageContent":"![Server and Client Components](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1669651658/nextjs-docs/darkmode/sequential-parallel-data-fetching.png)\n\n  * With **parallel data fetching** , requests in a route are eagerly initiated and will load data at the same time. This reduces client-server waterfalls and the total time it takes to load data.\n  * With **sequential data fetching** , requests in a route are dependent on each other and create waterfalls. There may be cases where you want this pattern because one fetch depends on the result of the other, or you want a condition to be satisfied before the next fetch to save resources. However, this behavior can also be unintentional and lead to longer loading times.\n\n\n\n[Learn how to implement parallel and sequential data fetching](/docs/data-fetching/fetching#data-fetching-patterns).","metadata":{"source":"NextAPI.md"}}],["32",{"pageContent":"[Learn how to implement parallel and sequential data fetching](/docs/data-fetching/fetching#data-fetching-patterns).\n\nIf you need to fetch the same data (e.g. current user) in multiple components in a tree, Next.js will automatically cache `fetch` requests (`GET`) that have the same input in a temporary cache. This optimization prevents the same data from being fetched more than once during a rendering pass.\n\n![Deduplication in a component tree](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1673006076/nextjs-docs/darkmode/deduplicated-fetch-requests.png)","metadata":{"source":"NextAPI.md"}}],["33",{"pageContent":"![Deduplication in a component tree](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1673006076/nextjs-docs/darkmode/deduplicated-fetch-requests.png)\n\n  * On the server, the cache lasts the lifetime of a server request until the rendering process completes.\n    * This optimization applies to `fetch` requests made in Layouts, Pages, Server Components, `generateMetadata` and `generateStaticParams`.\n    * This optimization also applies during [static generation](/docs/rendering/fundamentals#static-rendering).\n  * On the client, the cache lasts the duration of a session (which could include multiple client-side re-renders) before a full page reload.\n\n\n\n> **Good to know:**\n>\n>   * `POST` requests are not automatically deduplicated. [Learn more about caching](/docs/data-fetching/caching).\n>   * If you're unable to use `fetch`, React provides a [`cache` function](/docs/data-fetching/caching#per-request-cachingmd) to allow you to manually cache data for the duration of the request.\n>","metadata":{"source":"NextAPI.md"}}],["34",{"pageContent":"There are two types of data: **Static** and **Dynamic**.\n\n  * **Static Data** is data that doesn't change often. For example, a blog post.\n  * **Dynamic Data** is data that changes often or can be specific to users. For example, a shopping cart list.\n\n![Dynamic and Static Data Fetching](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1669662198/nextjs-docs/darkmode/dynamic-and-static-data-fetching.png)\n\nBy default, Next.js automatically does static fetches. This means that the data will be fetched at build time, cached, and reused on each request. As a developer, you have control over how the static data is [cached](/docs/data-fetching/fundamentals#caching-data) and [revalidated](/docs/data-fetching/fundamentals#revalidating-data).\n\nThere are two benefits to using static data:\n\n  1. It reduces the load on your database by minimizing the number of requests made.\n  2. The data is automatically cached for improved loading performance.","metadata":{"source":"NextAPI.md"}}],["35",{"pageContent":"There are two benefits to using static data:\n\n  1. It reduces the load on your database by minimizing the number of requests made.\n  2. The data is automatically cached for improved loading performance.\n\n\n\nHowever, if your data is personalized to the user or you want to always fetch the latest data, you can mark requests as _dynamic_ and fetch data on each request without caching.\n\n[Learn how to do Static and Dynamic data fetching](/docs/data-fetching/fetching#static-data-fetchingmd).\n\nCaching is the process of storing data in a location (e.g. [Content Delivery Network](https://vercel.com/docs/concepts/edge-network/overview)) so doesn't need to be re-fetched from the original source on each request.\n\n![Static Site Generation with Caching](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1669662196/nextjs-docs/darkmode/static-site-generation_1.png)","metadata":{"source":"NextAPI.md"}}],["36",{"pageContent":"![Static Site Generation with Caching](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1669662196/nextjs-docs/darkmode/static-site-generation_1.png)\n\nThe **Next.js Cache** is a persistent [HTTP cache](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching) that can be globally distributed. This means the cache can scale automatically and be shared across multiple regions depending on your platform (e.g. [Vercel](https://vercel.com/docs/concepts/next.js/overview)).\n\nNext.js extends the [options object](https://developer.mozilla.org/en-US/docs/Web/API/fetch#:~:text=preflight%20requests.-,cache,-A%20string%20indicating) of the `fetch()` function to allow each request on the server to set its own persistent caching behavior. Together with [component-level data fetching](/docs/data-fetching/fundamentals#component-level-data-fetching), this allows you to configure caching within your application code directly where the data is being used.","metadata":{"source":"NextAPI.md"}}],["37",{"pageContent":"During server rendering, when Next.js comes across a fetch, it will check the cache to see if the data is already available. If it is, it will return the cached data. If not, it will fetch and store data for future requests.\n\n> **Good to know:** If you're unable to use `fetch`, React provides a [`cache` function](/docs/data-fetching/caching#per-request-cachingmd) to allow you to manually cache data for the duration of the request.\n\n[Learn more about caching in Next.js](/docs/data-fetching/caching).\n\nRevalidation is the process of purging the cache and re-fetching the latest data. This is useful when your data changes and you want to ensure your application shows the latest version without having to rebuild your entire application.\n\nNext.js provides two types of revalidation:","metadata":{"source":"NextAPI.md"}}],["38",{"pageContent":"Next.js provides two types of revalidation:\n\n  * [**Background**](/docs/data-fetching/revalidating#background-revalidation): Revalidates the data at a specific time interval.\n  * [**On-demand**](/docs/data-fetching/revalidating#on-demand-revalidation): Revalidates the data whenever there is an update.\n\n\n\n[Learn how to revalidate data](/docs/data-fetching/revalidating).\n\nStreaming and [Suspense](https://beta.reactjs.org/apis/react/Suspense) are new React features that allow you to progressively render and incrementally stream rendered units of the UI to the client.\n\nWith Server Components and [nested layouts](/docs/routing/pages-and-layouts), you're able to instantly render parts of the page that do not specifically require data, and show a [loading state](/docs/routing/loading-ui) for parts of the page that are fetching data. This means the user does not have to wait for the entire page to load before they can start interacting with it.","metadata":{"source":"NextAPI.md"}}],["39",{"pageContent":"![Server Rendering with Streaming](https://assets.vercel.com/image/upload/f_auto,q_100,w_1600/v1666631081/nextjs-docs/darkmode/server-rendering-with-streaming-alt.png)\n\nTo learn more about Streaming and Suspense, see the [Loading UI](/docs/routing/loading-ui) and [Streaming and Suspense](/docs/data-fetching/streaming-and-suspense) pages.\n\n[Learn how to fetch data in your Next.js application.](/docs/data-fetching/fetching)\n\n\n# [Configuring: next.config.js](https://beta.nextjs.org/docs/api-reference/next.config.js)\n\nNext.js can be configured through a `next.config.js` file in the root of your project directory.\n\nnext.config.js\n\n\n    const nextConfig = { }; module.exports = nextConfig;\n\n\n> **Note:** `next.config.mjs` is also supported if you prefer ES Modules.\n\nThis page documents the configuration options specific to the `/app` directory. For a full list of all available options, please view the [next.config.js (stable) documentation](https://nextjs.org/docs/api-reference/next.config.js/introduction).","metadata":{"source":"NextAPI.md"}}],["40",{"pageContent":"The App Router ([`app` directory](/docs/routing/fundamentals)) enables support for [layouts](/docs/routing/pages-and-layouts), [Server Components](/docs/rendering/server-and-client-components#server-components), [streaming](/docs/data-fetching/streaming-and-suspense), and [colocated data fetching](/docs/data-fetching/fundamentals).\n\nUsing the `app` directory will automatically enable [React Strict Mode](https://beta.reactjs.org/reference/react/StrictMode). Learn how to [incrementally adopt `app`](/docs/upgrade-guide#migrating-from-pages-to-app).\n\nnext.config.js\n\n\n    const nextConfig = { experimental: { appDir: true, },\n    }; module.exports = nextConfig;\n\n\nFor use with `@next/mdx`. Compile MDX files using the new Rust compiler.\n\nnext.config.js\n\n\n    const withMDX = require('@next/mdx')(); const nextConfig = { pageExtensions: ['ts', 'tsx', 'mdx'], experimental: { appDir: true, mdxRs: true, }\n    }; module.exports = withMDX(nextConfig);","metadata":{"source":"NextAPI.md"}}],["41",{"pageContent":"const withMDX = require('@next/mdx')(); const nextConfig = { pageExtensions: ['ts', 'tsx', 'mdx'], experimental: { appDir: true, mdxRs: true, }\n    }; module.exports = withMDX(nextConfig);\n\n\nExperimental support for [statically typed links](/docs/configuring/typescript#statically-typed-links). This feature requires using the `app` directory flag (`appDir: true`), as well as TypeScript in your project.\n\nnext.config.js\n\n\n    const nextConfig = { experimental: { appDir: true, typedRoutes: true, },\n    }; module.exports = nextConfig;\n\n\nDependencies used inside [Server Components](/docs/rendering/server-and-client-components#server-components) and [Route Handlers](/docs/routing/route-handlers) will automatically be bundled by Next.js.\n\nIf a dependency is using Node.js specific features, you can choose to opt-out specific dependencies from the Server Components bundling and use native Node.js `require`.\n\nnext.config.js","metadata":{"source":"NextAPI.md"}}],["42",{"pageContent":"If a dependency is using Node.js specific features, you can choose to opt-out specific dependencies from the Server Components bundling and use native Node.js `require`.\n\nnext.config.js\n\n\n    const nextConfig = { experimental: { serverComponentsExternalPackages: ['@acme/ui'], },\n    }; module.exports = nextConfig;\n\n\nNext.js includes a [short list of popular packages](https://github.com/vercel/next.js/blob/canary/packages/next/src/lib/server-external-packages.json) that currently are working on compatibility and automatically opt-ed out:\n\n  * `@prisma/client`\n  * `@sentry/nextjs`\n  * `@sentry/node`\n  * `autoprefixer`\n  * `aws-crt`\n  * `bcrypt`\n  * `cypress`\n  * `eslint`\n  * `express`\n  * `firebase-admin`\n  * `jest`\n  * `lodash`\n  * `mongodb`\n  * `next-mdx-remote`\n  * `next-seo`\n  * `postcss`\n  * `prettier`\n  * `prisma`\n  * `rimraf`\n  * `sharp`\n  * `shiki`\n  * `sqlite3`\n  * `tailwindcss`\n  * `ts-node`\n  * `typescript`\n  * `vscode-oniguruma`\n  * `webpack`","metadata":{"source":"NextAPI.md"}}],["43",{"pageContent":"Next.js 13 can automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (`node_modules`). This replaces the `next-transpile-modules` package.\n\nnext.config.js\n\n\n    const nextConfig = { transpilePackages: ['@acme/ui', 'lodash-es'],\n    }; module.exports = nextConfig;\n\n\nBy default, Next.js accepts files with the following extensions: `.tsx`, `.ts`, `.jsx`, `.js`. This can be modified to allow other extensions like markdown (`.md`, `.mdx`).\n\nnext.config.js\n\n\n    const withMDX = require('@next/mdx')(); const nextConfig = { pageExtensions: ['ts', 'tsx', 'mdx'], experimental: { appDir: true, mdxRs: true, }\n    }; module.exports = withMDX(nextConfig);","metadata":{"source":"NextAPI.md"}}]]